"use strict";
const dotty = require("dotty");
const minimist = require("minimist");
const type_1 = require("./type");
function isDefined(value) {
    return value !== undefined && value !== null;
}
class Property {
    constructor(path, definition) {
        this.path = path;
        this.definition = definition;
        if (!Property.isProperty(definition)) {
            throw new Error(`Property definition for ${path} is not a valid property`);
        }
        const name = path.split('.').pop();
        if (~Property.reservedKeys.indexOf(name)) {
            throw new Error(`Property name ${name} is reserved`);
        }
        const type = type_1.default.get(definition.type);
        if (!type) {
            throw new Error(`Property type for ${path} is not a valid type`);
        }
        this.type = type;
    }
    static isProperty(obj) {
        // Every key in object is a Property key
        // AND
        // Every required key is present
        return Object.keys(obj).every((key) => !!~Property.reservedKeys.indexOf(key)) && Property.requiredKeys.every((key) => Reflect.has(obj, key));
    }
    static isNested(obj) {
        return Object.keys(obj).every((key) => !~Property.reservedKeys.indexOf(key));
    }
    resolve(rawConfig) {
        const { resolve, argv, env, type } = this.definition;
        let rawValue;
        // Use minimist here to make sure we have a clean parsing of the CLI
        const parsedArgs = minimist(process.argv);
        if (argv && Reflect.has(parsedArgs, argv)) {
            rawValue = parsedArgs[argv];
            if (isDefined(rawValue))
                return rawValue;
        }
        if (env && Reflect.has(process.env, env)) {
            rawValue = process.env[env];
            if (isDefined(rawValue))
                return rawValue;
        }
        if (resolve) {
            rawValue = resolve(rawConfig);
            if (isDefined(rawValue))
                return rawValue;
        }
        if (dotty.exists(rawConfig, this.path)) {
            rawValue = dotty.get(rawConfig, this.path);
            if (isDefined(rawValue))
                return rawValue;
        }
        return this.definition.default;
    }
    cast(value, config) {
        return (!isDefined(value)) ? value : this.type.cast(value, config);
    }
    transform(value, rawConfig) {
        if (!(isDefined(value) && this.definition.transform))
            return value;
        return this.definition.transform(value, rawConfig);
    }
    validate(value, config) {
        const defined = isDefined(value);
        if ((!defined) && this.definition.required) {
            throw new Error(`${this.path} is a required parameter but no value was provided`);
        }
        else if (!defined) {
            return;
        }
        const typeError = this.type.validate(value, config);
        if (isDefined(typeError))
            throw new Error(`${this.path}: ${typeError}`);
    }
}
Property.reservedKeys = [
    'description',
    'type',
    'default',
    'required',
    'env',
    'argv',
    'resolve',
    'transform'
];
Property.requiredKeys = [
    'description',
    'type'
];
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Property;
