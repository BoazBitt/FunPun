"use strict";
const dotty = require("dotty");
const property_1 = require("./property");
const type_1 = require("./type");
const number_1 = require("./types/number");
const boolean_1 = require("./types/boolean");
const string_1 = require("./types/string");
const array_1 = require("./types/array");
const object_1 = require("./types/object");
const path_1 = require("./types/path");
function getter(config, property, path, rawValue, flags) {
    let value;
    switch (typeof rawValue) {
        case 'function':
            value = rawValue(config, path);
            break;
        case 'string':
            value = rawValue.replace(/(\$\{([^\}]*)\})/gi, (match, group1, key) => config[key]);
            break;
        default:
            value = rawValue;
    }
    if (flags.transform)
        value = property.transform(value, config);
    if (flags.cast)
        value = property.cast(value, config);
    if (flags.validate)
        property.validate(value, config);
    return value;
}
;
class Schema {
    static parse(rawDefinition, startingPath) {
        // 1. Loop through keys on object
        // 2. Determine if value assigned to key is a Property or a nested object
        // 3. Convert properties to Property objects
        // 4. Parse nested values recursively
        const parsedObj = {};
        Object.keys(rawDefinition).forEach((key) => {
            const definition = rawDefinition[key];
            const fullPath = startingPath ? [startingPath, key].join('.') : key;
            if (property_1.default.isProperty(definition)) {
                parsedObj[fullPath] = new property_1.default(fullPath, definition);
            }
            else if (property_1.default.isNested(definition)) {
                Object.assign(parsedObj, Schema.parse(definition, fullPath));
            }
            else {
                throw new Error(`Property definition for ${fullPath} is illegal`);
            }
        });
        return parsedObj;
    }
    static addType(name, definition) {
        type_1.default.set(name, definition);
    }
    constructor(rawDefinition) {
        this.definition = Schema.parse(rawDefinition);
    }
    hydrate(rawConfig, options = {}) {
        const flags = {
            transform: !Reflect.has(options, 'transform') || options.transform,
            cast: !Reflect.has(options, 'cast') || options.cast,
            validate: !Reflect.has(options, 'validate') || options.validate,
        };
        // Find all the schema paths we need to trace
        const paths = Object.keys(this.definition);
        // Loop over and hydrate the object with getters
        const hydratedConfig = paths.reduce((config, path) => {
            const property = this.definition[path];
            const curriedGetter = getter.bind(this, config, property, path, property.resolve(rawConfig), flags);
            Object.defineProperty(config, path, { get: curriedGetter });
            return config;
        }, {});
        // Evaluate each of the paths provided in the schema
        return paths.reduce((config, key) => {
            dotty.put(config, key, hydratedConfig[key]);
            return config;
        }, {});
    }
    document() {
        // Trace the paths and build string versions of all the property keys
        return Object.keys(this.definition).reduce((definition, path) => {
            definition[path] = property_1.default.reservedKeys.reduce((obj, key) => {
                const value = this.definition[path].definition[key];
                if (value === undefined)
                    return obj;
                obj[key] = value.toString();
                return obj;
            }, {});
            return definition;
        }, {});
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Schema;
Schema.addType('number', number_1.default);
Schema.addType('string', string_1.default);
Schema.addType('boolean', boolean_1.default);
Schema.addType('array', array_1.default);
Schema.addType('object', object_1.default);
Schema.addType('path', path_1.default);
